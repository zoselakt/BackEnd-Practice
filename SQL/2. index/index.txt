인덱스 생성 (컬럼 중복 X)
CREATE INDEX [인덱스명] ON [테이블명](컬럼1, 컬럼2, 컬럼3.......)

삭제
DROP INDEX [인덱스 명]

특징
1. 검색 처리 속도를 향상시킨다. 
2. 비용이 비싸다 -> 인덱스를 create 해주어야 하기 때문

인덱스 사용해야 하는 경우(중요)
 1. 테이블 행의 갯수가 많은 경우.(찾아야할 데이터)
 2. 인덱스를 적용한 컬럼이 where 절에서 많이 사용되는 경우 (*****)
 3. join할 때 사용하는 컬럼(on 부모테이블.PK = 자식테이블.FK) (*****)
 4. 검색 결과가 원본 테이블 데이터 2 ~ 4%에 해당하는 경우 (*****)
 5. 해당 컬럼이 null을 포함하는 경우(색인에 null이 제외)

인덱스 사용하면 안 좋은 경우
 1. 테이블의 행의 갯수가 적은 경우
 2. 검색결과가 원본테이블의 많은 비중을 차지하는 경우.
 3. 원본 테이블의 삽입, 수정, 삭제가 빈번한 경우(*****)

단일 인덱스
>> create index idxIndexEmail on tblIndex(email) email 컬럼에만 index 부여

결합(다중) 인덱스
>> create index idxIndexEmailAge on tblIndex(email,age); 
--> 이렇게 해주어야 위의 상황에서 인덱스 효과를 받을 수 있다.

인덱스 리빌드
--문법
ALTER INDEX [인덱스명] REBUILD;

SELECT 
  I.TABLESPACE_NAME
, I.TABLE_NAME
, I.INDEX_NAME
, I.BLEVEL
, DECODE(SIGN(NVL(I.BLEVEL,99)-3),1,DECODE(NVL(I.BLEVEL,99),99,'?','Rebuild'),'Check') CNF
FROM   
 USER_INDEXES I
WHERE 
 I.BLEVEL > 4
ORDER BY 
I.BLEVEL 
DESC

인덱스(Index)를 남발하지 말아야 하는 이유
개발을 진행할때에 대개 개발서버와 운영서버를 나누어서 관리합니다. 
대부분 개발서버에서 개발을 할때에는 적은량의 데이터를 가지고 로직검사를 하며 
로직검사에 통과한 코드들이 운영서버에 업데이트가 되죠. 
하지만 개발서버에는 잘 동작하던 로직들이 운영서버의 많은량의 데이터들을 처리하다보면
성능이슈가 많이 발생합니다. 그 성능이슈의 주요원인은 바로 데이터베이스에 있습니다. 
데이터베이스 관리자는 성능문제가 발생하면 가장 빨리 생각하는 해결책이 인덱스 추가 생성입니다.

하지만 문제를 그저 쉽게 해결하기 위해 쿼리 속도 문제가 날때마다 인덱스를 추가하는것은 
바람직하지 못합니다. 성능 이슈가 나서 인덱스를 만들고 또 다른 SQL에서문에서 
성능이슈가 발생하여 또 인덱스를 만들었다고 합시다. 이렇게 문제가 발생할때마다 
인덱스를 생성하면서 인덱스가 계속 추가되면 생성된 인덱스를 참조하는 
하나의 쿼리문을 빠르게는 만들 수 있지만 전체적인 데이터베이스의 성능 부하를 초래합니다. 
그렇기에 인덱스를 생성하는것 보다는 SQL문을 좀 더 효율적으로 짜는 방향으로 나가야합니다. 
인덱스생성은 꼭 마지막 수단으로 강구해야 할 문제입니다.